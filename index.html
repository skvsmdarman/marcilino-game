<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Dark Knight's Ascent</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Anton&family=Cinzel:wght@700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #05070a;
            overflow: hidden;
            font-family: 'Anton', sans-serif;
            color: white;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000000, #09141d, #1c3b4a);
            transition: background 1s ease;
        }

        #background-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 15vw;
            text-align: center;
            line-height: 0.85;
            opacity: 0.1;
            pointer-events: none;
            white-space: nowrap;
            background: linear-gradient(to bottom, #fff, #5f8d9e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            z-index: 0;
            transition: opacity 2s ease;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #score {
            font-family: 'Cinzel', serif;
            font-size: 24px;
            text-shadow: 0 0 10px #00d2ff;
        }

        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            z-index: 25;
            display: none;
            pointer-events: none;
        }

        @media (max-width: 1024px) {
            #touch-controls { display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; }
            #controls-hint { display: none; }
        }

        .control-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: rgba(255, 255, 255, 0.7);
            user-select: none;
            backdrop-filter: blur(4px);
        }
        
        .control-btn:active {
            background: rgba(0, 210, 255, 0.4);
            transform: scale(0.95);
        }

        .d-pad {
            display: flex;
            gap: 20px;
            align-self: flex-end;
        }
        
        .action-pad {
            align-self: flex-end;
        }

        #start-screen, #win-screen, #game-over-screen, #next-level-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: auto;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, #7aaebf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.5));
        }

        .stage2-theme h1 {
            background: linear-gradient(to bottom, #fff, #bf7a7a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 50, 0, 0.5));
        }

        p {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            max-width: 600px;
            margin: 20px;
            line-height: 1.5;
            color: #ccc;
        }

        button {
            background: transparent;
            border: 2px solid #00d2ff;
            color: #00d2ff;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Anton', sans-serif;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.2);
            margin-top: 20px;
        }

        button:hover {
            background: #00d2ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.8);
        }

        .stage2-btn {
            border-color: #ff4500;
            color: #ff4500;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.2);
        }
        .stage2-btn:hover {
            background: #ff4500;
            color: #fff;
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
        }

        .hidden {
            display: none !important;
        }

    </style>
</head>
<body>

<div id="game-container">
    <div id="background-text">
        MARCILINO<br>ASCENT
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score">ALTITUDE: 0m | STAGE 1</div>
        <div id="controls-hint">Arrows to Move • Space to Jump</div>
        
        <div id="touch-controls">
            <div class="d-pad">
                <div class="control-btn" id="btn-left">←</div>
                <div class="control-btn" id="btn-right">→</div>
            </div>
            <div class="action-pad">
                <div class="control-btn" id="btn-jump">↑</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Marcilino Ascent</h1>
        <p>Gotham is drowning in darkness. Only the light above can save it.</p>
        <p>Ascend through the rain. Don't fall.</p>
        <button id="start-btn">Begin Crusade</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #ff3333; font-size: 5rem;">FALLEN</h1>
        <p>The darkness has claimed you.</p>
        <button id="retry-btn">Try Again</button>
    </div>

    <div id="next-level-screen" class="hidden">
        <h1>The Light Reached</h1>
        <p>But the crusade is not over. The Inferno awaits.</p>
        <button id="next-level-btn" class="stage2-btn">Enter The Inferno</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1 style="font-size: 6rem;">REDEMPTION</h1>
        <p>You have conquered the darkness and the fire.</p>
        <button id="restart-btn">Play Again</button>
    </div>
</div>

<script>
    // --- Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const container = document.getElementById('game-container');
    
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const nextLevelScreen = document.getElementById('next-level-screen');
    const winScreen = document.getElementById('win-screen');
    
    const startBtn = document.getElementById('start-btn');
    const retryBtn = document.getElementById('retry-btn');
    const nextLevelBtn = document.getElementById('next-level-btn');
    const restartBtn = document.getElementById('restart-btn');
    const bgText = document.getElementById('background-text');

    let width, height;
    let gameActive = false;
    let score = 0;
    let cameraY = 0;
    let currentStage = 1;

    // Level Configurations
    const stages = {
        1: {
            gravity: 0.6,
            speed: 6,
            jumpStrength: -16,
            winHeight: 3000,
            bg: "linear-gradient(to bottom, #000000, #09141d, #1c3b4a)",
            platformColor: "#3a3a3a",
            rainColor: "rgba(174, 194, 224, 0.5)",
            name: "STAGE 1"
        },
        2: {
            gravity: 0.75,
            speed: 8.5,
            jumpStrength: -18,
            winHeight: 5000,
            bg: "linear-gradient(to bottom, #2e0505, #591010, #8a3c1c)",
            platformColor: "#542626",
            rainColor: "rgba(255, 100, 50, 0.5)",
            name: "STAGE 2: INFERNO"
        }
    };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const keys = {
        ArrowLeft: false,
        ArrowRight: false,
        Space: false
    };

    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') keys.Space = true;
        if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
        if(e.code === 'ArrowRight') keys.ArrowRight = true;
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'Space') keys.Space = false;
        if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
        if(e.code === 'ArrowRight') keys.ArrowRight = false;
    });

    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnJump = document.getElementById('btn-jump');

    const handleBtnStart = (key) => (e) => { e.preventDefault(); keys[key] = true; };
    const handleBtnEnd = (key) => (e) => { e.preventDefault(); keys[key] = false; };

    btnLeft.addEventListener('touchstart', handleBtnStart('ArrowLeft'));
    btnLeft.addEventListener('touchend', handleBtnEnd('ArrowLeft'));
    btnRight.addEventListener('touchstart', handleBtnStart('ArrowRight'));
    btnRight.addEventListener('touchend', handleBtnEnd('ArrowRight'));
    btnJump.addEventListener('touchstart', handleBtnStart('Space'));
    btnJump.addEventListener('touchend', handleBtnEnd('Space'));

    btnLeft.addEventListener('mousedown', () => keys.ArrowLeft = true);
    btnLeft.addEventListener('mouseup', () => keys.ArrowLeft = false);
    btnRight.addEventListener('mousedown', () => keys.ArrowRight = true);
    btnRight.addEventListener('mouseup', () => keys.ArrowRight = false);
    btnJump.addEventListener('mousedown', () => keys.Space = true);
    btnJump.addEventListener('mouseup', () => keys.Space = false);

    class Player {
        constructor() {
            this.w = 40;
            this.h = 60;
            this.x = width / 2 - this.w / 2;
            this.y = height - 150;
            this.vx = 0;
            this.vy = 0;
            
            const settings = stages[currentStage];
            this.speed = settings.speed;
            this.jumpStrength = settings.jumpStrength;
            this.gravity = settings.gravity;
            
            this.grounded = false;
            this.facingRight = true;
        }

        update() {
            if (keys.ArrowLeft) {
                this.vx = -this.speed;
                this.facingRight = false;
            } else if (keys.ArrowRight) {
                this.vx = this.speed;
                this.facingRight = true;
            } else {
                this.vx *= 0.8;
                if(Math.abs(this.vx) < 0.1) this.vx = 0;
            }

            this.x += this.vx;

            if (this.x + this.w < 0) this.x = width;
            if (this.x > width) this.x = -this.w;

            if (keys.Space && this.grounded) {
                this.vy = this.jumpStrength;
                this.grounded = false;
            }

            this.vy += this.gravity;
            this.y += this.vy;

            if (this.y + this.h > height && cameraY === 0) {
                this.y = height - this.h;
                this.vy = 0;
                this.grounded = true;
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);
            if (!this.facingRight) ctx.scale(-1, 1);
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(-15, -20);
            ctx.quadraticCurveTo(-25, 10, -20, 30); 
            ctx.lineTo(20, 30);
            ctx.quadraticCurveTo(25, 10, 15, -20); 
            ctx.fill();

            ctx.fillRect(-10, -20, 20, 50);

            ctx.beginPath();
            ctx.moveTo(-8, -20);
            ctx.lineTo(-8, -35); 
            ctx.lineTo(-3, -25);
            ctx.lineTo(3, -25);
            ctx.lineTo(8, -35); 
            ctx.lineTo(8, -20);
            ctx.fill();

            ctx.fillStyle = currentStage === 1 ? '#fff' : '#ffaa00';
            ctx.beginPath();
            ctx.moveTo(-5, -28);
            ctx.lineTo(-1, -26);
            ctx.lineTo(-5, -26);
            ctx.fill();
            
            ctx.restore();
        }
    }

    class Platform {
        constructor(x, y, w) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = 15;
            this.color = stages[currentStage].platformColor;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x, this.y, this.w, this.h);
        }
    }

    class Rain {
        constructor() {
            this.drops = [];
            this.count = 200;
            for(let i=0; i<this.count; i++) {
                this.drops.push(this.resetDrop());
            }
        }

        resetDrop() {
            return {
                x: Math.random() * width,
                y: Math.random() * height,
                l: Math.random() * 20 + 10,
                s: Math.random() * 10 + 10
            };
        }

        updateAndDraw() {
            ctx.strokeStyle = stages[currentStage].rainColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let d of this.drops) {
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.x, d.y + d.l);
                d.y += d.s;
                if (d.y > height) {
                    Object.assign(d, this.resetDrop());
                    d.y = -d.l;
                }
            }
            ctx.stroke();
        }
    }

    class TheCross {
        constructor() {
            this.y = -stages[currentStage].winHeight + 100;
            this.w = 60;
            this.h = 100;
            this.glow = 0;
            this.glowDir = 1;
        }

        draw() {
            let drawY = this.y + cameraY;
            let drawX = width / 2;

            this.glow += 0.5 * this.glowDir;
            if (this.glow > 30 || this.glow < 10) this.glowDir *= -1;

            ctx.save();
            ctx.translate(drawX, drawY);
            
            ctx.shadowBlur = this.glow + 20;
            ctx.shadowColor = currentStage === 1 ? 'white' : 'orange';
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(-10, -50, 20, 100);
            ctx.fillRect(-35, -20, 70, 20);

            ctx.restore();
        }
    }

    let player;
    let platforms = [];
    let rain;
    let goal;

    function initGame() {
        const settings = stages[currentStage];
        container.style.background = settings.bg;
        
        player = new Player();
        rain = new Rain();
        goal = new TheCross();
        platforms = [];
        cameraY = 0;
        score = 0;
        
        // Initial Platform
        platforms.push(new Platform(width/2 - 100, height - 50, 200));

        // Generate Platforms - FIXED DISTANCES HERE
        let currentY = height - 150;
        while (currentY > -settings.winHeight) {
            // REDUCED GAP DISTANCE: Was 100 + random*60, now 70 + random*50
            let gap = 70 + Math.random() * 50; 
            if(currentStage === 2) gap += 20; 
            
            currentY -= gap;
            
            // INCREASED WIDTH: Was 80 + random*100, now 100 + random*80
            let pWidth = 100 + Math.random() * 80;
            if(currentStage === 2) pWidth -= 20;

            let pX = Math.random() * (width - pWidth);
            platforms.push(new Platform(pX, currentY, pWidth));
        }
    }

    function update() {
        if (!gameActive) return;

        player.update();

        // Camera Follow
        if (player.y < height / 2) {
            let diff = (height / 2) - player.y;
            player.y = height / 2;
            cameraY += diff;
            score += Math.floor(diff);
            
            let opacity = Math.min(1, score / stages[currentStage].winHeight);
            bgText.style.opacity = 0.1 + (opacity * 0.9);
        }

        // Platform Collision - FIXED MISSING FLOOR BUG
        player.grounded = false;
        for (let p of platforms) {
            let pScreenY = p.y + cameraY;
            
            // IMPORTANT FIX: Check platforms even if they are slightly below screen (height + 150)
            // This prevents the "floor disappearing" issue when jumping
            if (pScreenY < -50 || pScreenY > height + 150) continue;

            if (player.vy > 0 && 
                player.x + player.w > p.x && 
                player.x < p.x + p.w &&
                player.y + player.h > pScreenY &&
                player.y + player.h < pScreenY + p.h + player.vy + 5) { 
                
                player.y = pScreenY - player.h;
                player.vy = 0;
                player.grounded = true;
            }
        }

        // Win Condition
        if (score >= stages[currentStage].winHeight) {
            handleLevelComplete();
        }

        // GAME OVER Condition - Gives extra margin before death
        if (player.y > height + 50) {
            triggerGameOver();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        for (let p of platforms) {
            let pScreenY = p.y + cameraY;
            // Draw even if slightly off screen to match collision logic
            if (pScreenY > -50 && pScreenY < height + 150) {
                let originalY = p.y;
                p.y = pScreenY;
                p.draw();
                p.y = originalY;
            }
        }

        goal.draw();
        player.draw();
        rain.updateAndDraw();

        scoreEl.innerText = `ALT: ${Math.floor(score/10)}m | ${stages[currentStage].name}`;
    }

    function loop() {
        update();
        draw();
        if (gameActive) requestAnimationFrame(loop);
    }

    function startGame() {
        startScreen.classList.add('hidden');
        winScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        nextLevelScreen.classList.add('hidden');
        gameActive = true;
        initGame();
        loop();
    }

    function triggerGameOver() {
        gameActive = false;
        gameOverScreen.classList.remove('hidden');
    }

    function handleLevelComplete() {
        gameActive = false;
        if (currentStage === 1) {
            nextLevelScreen.classList.remove('hidden');
        } else {
            gameWin();
        }
    }

    function loadNextStage() {
        currentStage = 2;
        startGame();
    }

    function gameWin() {
        gameActive = false;
        winScreen.classList.remove('hidden');
        ctx.clearRect(0, 0, width, height);
        goal.y = height/2 - 50; 
        cameraY = 0;
        goal.draw();
        player.x = width/2 - player.w/2;
        player.y = height/2 + 60;
        player.draw();
        rain.updateAndDraw();
    }

    startBtn.addEventListener('click', () => {
        currentStage = 1;
        startGame();
    });
    
    retryBtn.addEventListener('click', () => {
        startGame();
    });

    nextLevelBtn.addEventListener('click', loadNextStage);

    restartBtn.addEventListener('click', () => {
        currentStage = 1;
        startGame();
    });

    rain = new Rain();
    function bgLoop() {
        if (!gameActive) {
            ctx.clearRect(0, 0, width, height);
            rain.updateAndDraw();
            requestAnimationFrame(bgLoop);
        }
    }
    bgLoop();

</script>
</body>
</html>
